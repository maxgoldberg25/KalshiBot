"""Market snapshot and strategy signal models."""

from datetime import datetime
from typing import Any, Optional

from pydantic import BaseModel, Field

from kalshi_bot.models.market import OrderBook
from kalshi_bot.models.order import OrderSide


class MarketSnapshot(BaseModel):
    """Point-in-time snapshot of market state for backtesting."""
    
    ticker: str
    timestamp: datetime
    
    # Price data
    last_price: int
    bid: Optional[int] = None
    ask: Optional[int] = None
    mid: Optional[float] = None
    spread: Optional[int] = None
    
    # Volume/depth
    volume_24h: int = 0
    bid_depth: int = 0
    ask_depth: int = 0
    
    # Derived features
    depth_imbalance: float = 0.0
    
    # Full orderbook (optional, for detailed analysis)
    orderbook_json: Optional[str] = Field(default=None, description="Serialized orderbook")
    
    @classmethod
    def from_market(cls, ticker: str, orderbook: OrderBook, last_price: int, volume_24h: int) -> "MarketSnapshot":
        """Create snapshot from market data."""
        return cls(
            ticker=ticker,
            timestamp=orderbook.timestamp,
            last_price=last_price,
            bid=orderbook.best_bid,
            ask=orderbook.best_ask,
            mid=orderbook.mid_price,
            spread=orderbook.spread,
            volume_24h=volume_24h,
            bid_depth=orderbook.bid_depth,
            ask_depth=orderbook.ask_depth,
            depth_imbalance=(
                (orderbook.bid_depth - orderbook.ask_depth) /
                max(orderbook.total_depth, 1)
            ),
        )


class StrategySignal(BaseModel):
    """Signal generated by a trading strategy."""
    
    # Identification
    strategy_name: str
    ticker: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    
    # Signal direction and strength
    side: Optional[OrderSide] = Field(default=None, description="None = no trade")
    confidence: float = Field(default=0.0, ge=0.0, le=1.0)
    
    # Probability estimates
    fair_probability: float = Field(description="Strategy's estimate of true probability")
    market_probability: float = Field(description="Market's implied probability")
    edge: float = Field(description="fair_prob - market_prob (for YES), or reverse for NO")
    
    # Expected value
    expected_value: float = Field(description="Expected return per dollar risked")
    
    # Price targets
    entry_price: Optional[int] = Field(default=None, description="Target entry price in cents")
    take_profit: Optional[int] = Field(default=None)
    stop_loss: Optional[int] = Field(default=None)
    
    # Backtest performance (if available)
    backtest_win_rate: Optional[float] = Field(default=None)
    backtest_samples: Optional[int] = Field(default=None)
    backtest_sharpe: Optional[float] = Field(default=None)
    
    # Metadata
    features_used: dict[str, Any] = Field(default_factory=dict)
    reasoning: str = Field(default="")
    
    @property
    def is_tradeable(self) -> bool:
        """Check if signal recommends a trade."""
        return self.side is not None and self.confidence > 0
    
    def meets_thresholds(
        self,
        min_confidence: float = 0.6,
        min_ev: float = 0.02,
        min_win_rate: float = 0.70,
        min_samples: int = 30,
    ) -> bool:
        """Check if signal meets trading thresholds."""
        if not self.is_tradeable:
            return False
        
        if self.confidence < min_confidence:
            return False
        
        if self.expected_value < min_ev:
            return False
        
        # Backtest requirements (if available)
        if self.backtest_win_rate is not None:
            if self.backtest_win_rate < min_win_rate:
                return False
            if self.backtest_samples is not None and self.backtest_samples < min_samples:
                return False
        
        return True


class BacktestResult(BaseModel):
    """Results from backtesting a strategy."""
    
    strategy_name: str
    ticker: str
    
    # Sample info
    start_date: datetime
    end_date: datetime
    num_samples: int
    num_trades: int
    
    # Performance
    win_rate: float
    total_return: float
    avg_return_per_trade: float
    max_drawdown: float
    sharpe_ratio: Optional[float] = None
    
    # Trade stats
    avg_win: float = 0.0
    avg_loss: float = 0.0
    profit_factor: Optional[float] = None  # gross profit / gross loss
    
    # Validity
    is_valid: bool = Field(default=True)
    reason_invalid: Optional[str] = Field(default=None)
    
    @classmethod
    def insufficient_data(cls, strategy_name: str, ticker: str, samples: int) -> "BacktestResult":
        """Create result for insufficient data."""
        return cls(
            strategy_name=strategy_name,
            ticker=ticker,
            start_date=datetime.utcnow(),
            end_date=datetime.utcnow(),
            num_samples=samples,
            num_trades=0,
            win_rate=0.0,
            total_return=0.0,
            avg_return_per_trade=0.0,
            max_drawdown=0.0,
            is_valid=False,
            reason_invalid=f"Insufficient samples: {samples}",
        )
